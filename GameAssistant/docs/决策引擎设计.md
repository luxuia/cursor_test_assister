# 决策引擎设计

## 一、当前架构概览

```
MainViewModel
    → 识别: HeroRoster / Minimap / Equipment / Status
    → 组装 GameState
    → DecisionEngine.AnalyzeAsync(gameState)
        → BuildConditionFromGameState(gameState)  → AdviceCondition
        → AdviceDatabase.QueryRulesAsync(condition)  → List<AdviceRule>
        → 转成 Advice + 去重 + 按优先级排序
    → CurrentAdviceList → Overlay 展示
```

- **输入**：`GameState`（英雄、小地图、装备、状态栏血量/技能、阶段）。
- **规则**：`AdviceRule` = `AdviceCondition` + 建议内容 + 优先级 + 类型，存于 `advice_rules.json`。
- **输出**：`List<Advice>`，按优先级排序、去重后给 UI 显示。

---

## 二、推荐整体流程（管道式）

把决策拆成清晰步骤，便于单独扩展和测试：

```
GameState → [1. 状态标准化] → Context
         → [2. 条件匹配]   → 候选规则集
         → [3. 规则评估]   → 带分数的规则
         → [4. 建议生成]   → 原始建议列表
         → [5. 后处理]     → 去重 / 限流 / 条数上限
         → List<Advice>
```

### 1. 状态标准化（Context）

- 把 `GameState` 转成引擎内部用的 **Context**（或沿用 `AdviceCondition` 作为“当前状态视图”）。
- 可包含：
  - 当前血量、技能可用/CD、装备 ID 列表、英雄 ID 列表。
  - 游戏阶段（前期/中期/后期）、小地图摘要（人数/区域，可选）。
  - 时间戳、上一帧状态（用于阶段推断、冷却等）。

目的：规则只依赖 Context，不直接依赖识别结果结构，方便以后加字段（如经济、等级）。

### 2. 条件匹配（规则筛选）

- 用 **Context** 对每条 `AdviceRule.Condition` 做匹配，得到“可能触发的规则”子集。
- 匹配语义建议：
  - **血量**：`HealthThreshold` 表示“血量低于该值触发”（当前已有）。
  - **阶段**：`Phase` 精确等于当前阶段（当前已有）。
  - **英雄**：`HeroCombination` 可为“包含某英雄”或“包含某组合”（需约定：是“包含即触发”还是“完全一致”）。
  - **装备**：`EquipmentCombination` 同上，如“已出 BKB”则触发某条建议。
  - **技能**：`SkillConditions` 表示某技能可用/不可用（如“大招就绪”触发开团建议）。
  - **地图/区域**：`MapRegion` 若启用，可和 Minimap 的简单区域或人数结合。

实现上：在 `AdviceDatabase.MatchesCondition(ruleCondition, gameCondition)` 里补全英雄/装备/技能的判断（见下节），必要时把“游戏状态”统一成 `AdviceCondition` 再比较。

### 3. 规则评估（可选，用于排序/过滤）

- 对候选规则算一个 **分数**（例如 0~1），用于：
  - 同优先级时的细排序；
  - 或过滤掉分数过低的规则（避免弱相关建议刷屏）。
- 简单做法：匹配到的规则直接用 `Priority`，不另算分；后续若要“匹配程度”，可在这里加（如装备匹配数/总条件数）。

### 4. 建议生成

- 对每条通过匹配的规则，生成一条 `Advice`：
  - `Content` = 规则的 `AdviceContent`（可支持简单占位符，如 `{HealthPercentage}` 替换为当前血量）；
  - `Priority`、`Type`、`Scenario`、`MatchedCondition` 与当前实现一致即可。

### 5. 后处理

- **去重**：内容或“语义”相近的只保留一条（当前已有按内容简单去重）。
- **限流**：同一规则 N 秒内只出现一次（避免闪烁）；可给 `AdviceRule` 加 `CooldownSeconds`，引擎内用 `_stateHistory` 或时间戳判断。
- **条数上限**：只取前 K 条（如 5～10），避免界面过长。

---

## 三、条件匹配语义建议（与现有模型对齐）

在保持 `AdviceCondition` 和 `AdviceRule` 不变的前提下，在 **AdviceDatabase.MatchesCondition** 中建议实现：

| 条件字段 | 含义 | 匹配方式 |
|----------|------|----------|
| `HealthThreshold` | 血量低于该值触发 | `game.HealthThreshold <= rule.HealthThreshold` |
| `Phase` | 游戏阶段 | `game.Phase == rule.Phase` |
| `HeroCombination` | 己方包含某英雄 | `rule` 中列出的英雄在 `game.HeroCombination` 中**至少出现一个**（或“全部出现”由配置决定） |
| `EquipmentCombination` | 已出某装备 | 同上，规则里列出的装备在 `game.EquipmentCombination` 中**至少有一个** |
| `SkillConditions` | 某技能可用/不可用 | 对规则中每个 `skillId -> isAvailable`，检查 `game.SkillConditions` 中该技能状态是否一致 |
| `MapRegion` | 地图区域 | 暂可留空或与 Minimap 简单绑定（如“己方人数 &gt; 3”等） |

- 若规则中某字段为 `null`/未设置，表示**不限制**该维度。
- 这样现有 JSON 规则只需按需填写条件，引擎即可按“与”关系组合（血量且阶段且英雄等）。

---

## 四、游戏阶段判定（Phase）

当前 `DetermineGamePhase` 未实现，可先做一版简单启发式，后续再接入真实时间或 API：

- **依据**：装备数量、技能数量、或“识别到的信息量”作为代理。
- 示例（需按实际调参）：
  - 装备数 &lt; 2 → Early；
  - 装备数 2～5 → Mid；
  - 装备数 &gt; 5 → Late；
- 或：根据 Status 里是否有“大招”图标、装备是否含关键装等做阶段判断。

阶段写入 `GameState.Phase`，决策引擎只读 `Phase` 做条件匹配。

---

## 五、规则侧扩展（可选）

- **冷却**：`AdviceRule.CooldownSeconds`，同一规则在 N 秒内不重复触发；引擎用 `_stateHistory` 或 `(ruleId, lastTriggerTime)` 判断。
- **一次性与重复**：如 `TriggerOncePerGame`，可在 Context 或引擎内维护“本局已触发规则 ID 集合”。
- **优先级与类型**：保持现有 `Priority`、`AdviceType`，用于排序和 UI 展示。

---

## 六、文件与职责划分

| 组件 | 职责 |
|------|------|
| `GameState` | 识别结果聚合，只做数据容器。 |
| `AdviceCondition` | 规则条件 + 当前状态视图（从 GameState 生成）。 |
| `AdviceRule` | 一条建议的完整定义（条件 + 内容 + 优先级 + 类型）。 |
| `IAdviceDatabase` | 规则存储与按条件查询（含 MatchesCondition 实现）。 |
| `IDecisionEngine` | 对外接口：`AnalyzeAsync(GameState)` → `List<Advice>`。 |
| `DecisionEngine` | 实现：状态→条件、查规则、生成建议、去重与排序；可逐步加入 Context、评估、限流。 |

建议：**条件匹配的细节**全部放在 `AdviceDatabase.MatchesCondition`（或抽成 `IConditionMatcher`），决策引擎只负责流程和调用，便于单测和换规则源。

---

## 七、小结

- **设计要点**：状态标准化 → 条件匹配 → 规则评估（可选）→ 建议生成 → 去重/限流/条数上限。
- **短期可做**：在 `MatchesCondition` 中补全英雄、装备、技能的匹配逻辑；实现一版简单的 `DetermineGamePhase`；保持现有接口与 JSON 规则格式。
- **中期可做**：为规则加冷却、条数上限；引入 Context 抽象；占位符替换（如 `{HealthPercentage}`）。
- **长期可做**：更细的地图/区域条件、与外部数据（如胜率、阵容克制）结合、或接入简单 ML 排序模型。

这样决策引擎就形成清晰、可扩展的“规则 + 条件 + 后处理”管道，便于后续加规则和调策略。
