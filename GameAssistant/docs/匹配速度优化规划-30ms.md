# 匹配速度优化规划：目标 30ms 内完成

## 一、当前瓶颈分析

### 1.1 每帧实际在做的事

- **装备识别** `RecognizeEquipmentByTemplate`：对 `Templates/Equipment/` 下**每个**物品模板调用一次 `Match(..., multiScale: true)`。
- **技能识别** `RecognizeSkills`：对 `Templates/Skills/` 下**每个**技能模板调用一次 `Match(..., multiScale: true)`。
- 英雄阵容同理，但通常模板数量较少。

### 1.2 单次 `Match(..., multiScale: true)` 的成本（TemplateMatcher.cs）

| 步骤 | 说明 | 次数/模板 |
|------|------|-----------|
| 转灰度 | 每调用一次 Match 就对**同一块区域**做一次 CvtColor/Clone | 1 次/模板 |
| 多尺度 | 7 个尺度 (0.75, 0.85, 0.95, 1.0, 1.08, 1.16, 1.25) | 7 次/模板 |
| 每尺度 | Resize 模板 → MatchTemplate → FindMatches | 7 × (Resize + MatchTemplate + FindMatches) |
| 去重 | RemoveDuplicateMatches | 1 次/模板 |

设装备模板数 **E**、技能模板数 **S**（数量级常见为几十～几百）：

- **MatchTemplate 调用次数** = 7×(E + S)（装备 + 技能，仅这两块）
- **同一区域转灰度** = E 次（装备区）+ S 次（状态栏区），重复劳动
- **模板 Resize** = 7×E + 7×S 次/帧，均在热路径上

例如 E=150、S=200 时：约 **2450 次** MatchTemplate + 350 次灰度转换 + 2450 次 Resize，总耗时很容易到几百 ms，与「30ms 内完成」差距巨大。

### 1.3 主流程

- `MainViewModel` 里装备、技能与英雄、小地图是 **Task.WhenAll 并行** 的，所以**总耗时 ≈ 四路里最慢的那一路**。
- 通常**装备 + 技能**两路是模板数量最多、最慢的，因此优化重点在这两路，目标是把「匹配」整段压到约 **30ms**（或整帧识别 ≤30ms，视你目标而定）。

---

## 二、优化目标与阶段

- **目标**：匹配（至少装备+技能）在 **30ms 量级** 内完成。
- **思路**：减少 MatchTemplate 次数、减少重复运算、提高并行度、必要时降分辨率或减尺度。

---

## 三、具体优化项（按建议实施顺序）

### 阶段 1：少做重复工作（预期可省 20%～40%）

#### 1.1 区域灰度只算一次

- **现状**：每个装备/技能模板调用一次 `Match()`，内部都对同一块 `regionMat` 做一次转灰度。
- **改法**：
  - 在 **ImageRecognizer** 里，裁剪出装备区域/状态栏区域后，**先转成灰度 Mat 一次**。
  - **TemplateMatcher** 增加重载：`Match(Mat graySource, string templateName, double threshold, bool multiScale)`，约定调用方保证传入已是 **CV_8UC1**，内部不再 CvtColor/Clone。
- **效果**：装备区 1 次灰度 + 状态栏 1 次灰度，替代 (E+S) 次，CPU 和缓存压力明显下降。

#### 1.2 多尺度模板预计算并缓存

- **现状**：每帧对每个模板在循环里做 7 次 `Cv2.Resize(template, scaledTemplate, ...)`，再 MatchTemplate。
- **改法**：
  - 在 **PreloadAllTemplates**（或首次使用某模板）时，按当前固定的 `scales[]` 预生成所有尺度的 Mat，以例如 `templateName + "_s" + scale` 为 key 存入 `_templateCache`。
  - **Match** 时只做：取预计算好的 scaled 模板 → MatchTemplate → FindMatches，不再在热路径 Resize。
- **效果**：消除每帧 7×(E+S) 次 Resize，并提升缓存命中率。

---

### 阶段 2：减少 MatchTemplate 调用次数（预期可省 50%～70%）

#### 2.1 减少多尺度数量

- **现状**：7 个尺度。
- **改法**：改为 3 个尺度，例如 `{ 0.92, 1.0, 1.08 }`（或根据你实际 UI 缩放范围微调）。
- **效果**：MatchTemplate 次数变为 3×(E+S)，约为原来的 3/7，匹配精度略降但通常仍可接受。

#### 2.2 可选：配置「单尺度」模式

- 若用户分辨率/DPI 固定，可增加配置项如 `UseSingleScaleForMatch = true`，仅用 1.0 尺度。
- **效果**：MatchTemplate 次数再降为 1×(E+S)，约再省 2/3（相对 3 尺度）。

---

### 阶段 3：并行化（预期 2～4 倍加速，视核心数而定）

#### 3.1 模板级并行

- **现状**：装备是 `foreach (var templateFile in templateFiles)` 串行；技能同理。
- **改法**：
  - 装备：`Parallel.ForEach(templateFiles, templateFile => { ... Match(regionMatGray, ...) ... })`，每个模板产出一批 `EquipmentInfo`，最后合并列表再做一次 `DedupeOverlappingEquipment`。
  - 技能：同理，`Parallel.ForEach` 得到 `allMatches`，再在外面做 `DedupeOverlappingSkillMatches`。
- **注意**：
  - 传入的 `regionMat`/灰度 Mat 只读，每个线程各自写自己的 result/List，不共享可写 Mat 即可。
  - OpenCvSharp 的 `Cv2.MatchTemplate` 等一般视为线程安全（每线程不同 Mat），但需避免多线程同时写同一 Mat。

#### 3.2 可选：区域级并行

- 当前英雄/小地图/装备/状态已通过 `Task.WhenAll` 并行，若单路内部再并行（如上），通常即可；若仍不足，可再考虑把「装备」和「技能」拆成更多子任务（例如装备按模板分段并行），但要权衡线程开销。

---

### 阶段 4：降分辨率 + 两阶段（在阶段 1～3 仍不够时考虑）

#### 4.1 半分辨率匹配

- 将装备区/状态栏区先 **Resize 到 0.5 倍**，模板也按 0.5 预缩放一份（或匹配时用 0.5 尺度）。
- **效果**：单次 MatchTemplate 复杂度约与像素数成正比，半分辨率约带来约 **4 倍** 单次加速；可先在全图 0.5 上粗匹配，再对少量候选在 1.0 上精匹配（可选）。

#### 4.2 两阶段：先粗筛再精匹配

- 例如用更小的模板或固定几个「代表模板」做一次快速粗筛，只对得分高于某阈值的模板再做全尺度/全模板匹配。实现复杂度和收益需要结合你当前模板集再定。

---

### 阶段 5：算法/基础设施（目标 <10ms 时考虑）

- **OpenCV GPU**：若运行环境有 OpenCV 的 CUDA/OpenCL 构建，可尝试 `cv::cuda::matchTemplate` 或 OpenCvSharp 的 UMat/GPU API（若封装可用），对大批量 MatchTemplate 通常有数量级提升。
- **特征匹配替代**：用 ORB 等做「是什么图标」的分类，再对位置做少量模板匹配，复杂度与模板数关系不同，可能更适合「模板数极大」的场景。
- **小神经网络**：用轻量级 CNN 做装备/技能图标分类（单次前向 <10ms），再仅对位置做模板或规则判断。

---

## 四、实施顺序建议（达到 30ms 的推荐路径）

1. **先做阶段 1**：灰度只算一次 + 多尺度模板预计算。  
   → 预期：当前若 200～400ms，可降到约 100～200ms 量级。

2. **再做阶段 2.1**：多尺度从 7 改为 3。  
   → 预期：再降约一半，到约 50～100ms。

3. **接着阶段 3**：装备与技能内部 `Parallel.ForEach` 模板。  
   → 预期：再降约 2～3 倍，有机会进入 20～50ms。

4. 若仍 >30ms：  
   - 启用 **2.2 单尺度** 或 **4.1 半分辨率** 之一或组合；  
   - 再考虑 **4.2 两阶段** 或 **5 GPU/特征/CNN**。

5. **度量**：在 `RecognizeEquipmentByTemplate` / `RecognizeSkills` 入口和出口打 `Stopwatch`，或用 `RecognizeFrameAsync` 的总耗时减去截屏与其它非匹配部分，得到「纯匹配耗时」，便于验证每步优化效果。

---

## 五、需要改动的文件（汇总）

| 文件 | 修改内容 |
|------|----------|
| `TemplateMatcher.cs` | ① 增加 `Match(Mat graySource, ...)` 重载，内部不转灰度；② 多尺度模板预计算并缓存；③ 可选：减少 scales 数量或从配置读取。 |
| `ImageRecognizer.cs` | ① 装备：裁剪区域后转灰度一次，调用新重载；② 技能：同上；③ 装备/技能循环改为 `Parallel.ForEach`，合并结果后再去重。 |
| `RecognitionParameters.cs` / `ConfigurationService.cs` | 可选：增加「多尺度数量」或「是否单尺度」等配置项，供 TemplateMatcher 使用。 |

---

## 六、预期结果（粗略）

- 仅做 **阶段 1+2.1+3**（灰度一次 + 预计算多尺度 + 3 尺度 + 并行）：  
  在 E+S 约 200～400 量级、4～8 核下，**匹配部分** 有机会从数百 ms 降到 **20～40ms**，接近或达到 30ms 目标。  
- 若仍不达标，再按顺序加上 2.2（单尺度）或 4.1（半分辨率）即可进一步压缩。
