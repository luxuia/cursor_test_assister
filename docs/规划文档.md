# 游戏辅助工具系统架构规划

> 本文档记录了游戏辅助工具的完整架构设计和开发规划

## 一、系统整体架构

### 1.1 核心模块划分

```
┌─────────────────────────────────────────────────────────────┐
│                      WPF 主界面层                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  建议浮窗UI   │  │  设置面板UI   │  │  状态监控UI   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    业务逻辑层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  决策分析引擎  │  │  数据匹配模块  │  │  状态管理模块  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    图像识别层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  画面采集模块  │  │  特征识别模块  │  │  模板匹配模块  │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    数据存储层                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  建议数据库   │  │  模板库      │  │  配置存储     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

## 二、详细模块设计

### 2.1 画面采集模块 (ScreenCapture)

**功能职责：**

- 实时捕获游戏窗口画面
- 支持全屏和窗口模式
- 帧率控制（目标60fps或可配置）

**技术实现：**

- 使用 `Windows Graphics Capture API` 或 `BitBlt` API
- 考虑使用 `DirectX` 或 `GDI+` 进行高效截图
- 异步采集，避免阻塞主线程

**输出：**

- Bitmap 格式的游戏画面帧

### 2.2 图像识别模块 (ImageRecognition)

**子模块划分：**

#### 2.2.1 英雄阵容识别 (HeroRosterRecognition)

- **识别区域：** 游戏界面固定位置（如顶部或侧边栏）
- **识别方法：** 
  - 模板匹配识别英雄头像
  - OCR识别英雄名称/ID
  - 颜色特征识别（血条颜色、状态图标）
- **输出：** 当前队伍英雄列表（ID、状态、位置）

#### 2.2.2 小地图站位识别 (MinimapRecognition)

- **识别区域：** 小地图区域（通常右下角）
- **识别方法：**
  - 颜色阈值识别英雄标记点
  - 坐标映射（小地图坐标 → 游戏世界坐标）
  - 移动轨迹分析
- **输出：** 各英雄在小地图上的位置坐标

#### 2.2.3 装备信息识别 (EquipmentRecognition)

- **触发条件：** Tab键按下或选中目标时
- **识别区域：** 装备面板区域
- **识别方法：**
  - 模板匹配识别装备图标
  - OCR识别装备名称/属性数值
  - 图像特征匹配（装备图标库）
- **输出：** 装备列表、属性数值

#### 2.2.4 血量和技能识别 (StatusRecognition)

- **识别区域：** HUD界面（血条、技能栏）
- **识别方法：**
  - 颜色分析识别血量百分比（血条颜色/长度）
  - 技能图标匹配识别可用技能
  - 冷却时间识别（技能图标灰度/透明度）
- **输出：** 血量百分比、技能状态、冷却时间

### 2.3 数据存储模块 (DataStorage)

#### 2.3.1 游戏建议数据库 (GameAdviceDatabase)

**数据结构设计：**

- **建议规则表：** 条件 → 建议内容的映射
  - 条件字段：英雄组合、装备组合、血量阈值、地图位置、游戏阶段等
  - 建议字段：行为建议文本、优先级、适用场景
- **存储格式：** SQLite 或 JSON 文件
- **数据来源：** 大模型预分析生成

#### 2.3.2 图像模板库 (TemplateLibrary)

- 英雄头像模板
- 装备图标模板
- 技能图标模板
- UI元素模板（血条、按钮等）

#### 2.3.3 配置存储

- 识别区域坐标配置
- 识别参数配置（阈值、匹配度等）
- 用户偏好设置

### 2.4 决策分析引擎 (DecisionEngine)

**工作流程：**

1. **数据聚合：** 收集当前帧所有识别结果
2. **状态分析：**
   - 当前游戏阶段判断（前期/中期/后期）
   - 团队阵容分析
   - 敌我对比分析
3. **规则匹配：** 在建议数据库中查找匹配的规则
4. **建议生成：** 根据匹配规则生成具体建议
5. **优先级排序：** 按紧急程度和重要性排序建议

**算法考虑：**

- 规则匹配算法（模糊匹配、精确匹配）
- 建议去重和合并
- 上下文记忆（最近几秒的状态变化）

### 2.5 UI显示模块 (UIDisplay)

#### 2.5.1 浮窗显示 (OverlayWindow)

- **特性：**
  - 置顶显示，不遮挡游戏操作
  - 半透明背景
  - 可拖拽位置
  - 可最小化/展开
- **内容显示：**
  - 当前建议列表（按优先级）
  - 关键信息摘要（血量、技能状态）
  - 实时识别状态指示

#### 2.5.2 设置面板

- 识别区域配置（可视化拖拽选择）
- 识别参数调整
- 数据库管理（导入/导出建议规则）
- 性能监控（FPS、识别耗时）

## 三、性能优化策略

### 3.1 帧率优化

- **多线程架构：**
  - 主线程：UI更新
  - 采集线程：画面捕获
  - 识别线程：图像处理
  - 分析线程：决策计算
- **帧率控制：** 可配置识别频率（如每2帧识别一次，降低CPU占用）

### 3.2 识别优化

- **区域裁剪：** 只识别必要的UI区域，不处理全屏
- **模板缓存：** 预加载模板到内存
- **增量识别：** 只识别变化区域（如装备面板打开时才识别）
- **识别优先级：** 关键信息优先识别（血量 > 装备 > 小地图）

### 3.3 内存管理

- **帧缓冲：** 限制缓存帧数，及时释放
- **图像压缩：** 识别前适当压缩，识别后释放
- **对象池：** 复用Bitmap对象，减少GC压力

## 四、技术选型

### 4.1 图像处理库

- **OpenCvSharp4**：C# 封装的 OpenCV，功能强大
- **EmguCV**：另一个 OpenCV 的 .NET 封装
- **AForge.NET**：轻量级图像处理库（备选）

### 4.2 UI框架

- **WPF**：主界面和浮窗
- **Win32 API**：用于创建透明置顶窗口

### 4.3 数据库

- **SQLite**：轻量级，适合存储建议规则
- **Entity Framework Core**：ORM框架（可选）

### 4.4 异步处理

- **Task/async-await**：异步图像处理
- **Producer-Consumer模式**：画面采集 → 识别队列

## 五、开发流程建议

### 阶段一：基础框架搭建

1. WPF主窗口和浮窗框架
2. 画面采集功能（先实现基础截图）
3. 简单的图像显示和调试界面

### 阶段二：核心识别功能

1. 实现一个识别模块（如血量识别）作为原型
2. 建立模板匹配流程
3. 优化识别准确率

### 阶段三：多模块集成

1. 逐步添加其他识别模块
2. 实现数据聚合和状态管理
3. 建立识别结果的数据结构

### 阶段四：决策引擎

1. 设计建议数据库结构
2. 实现规则匹配算法
3. 实现建议生成和排序

### 阶段五：性能优化

1. 多线程架构重构
2. 识别区域优化
3. 内存和CPU使用优化

### 阶段六：用户体验

1. UI美化
2. 配置界面完善
3. 错误处理和日志系统

## 六、关键技术难点

### 6.1 游戏窗口识别

- 如何准确找到游戏窗口（窗口标题、进程名匹配）
- 处理全屏模式下的画面捕获

### 6.2 识别准确性

- 不同分辨率/DPI下的适配
- 游戏UI更新导致的模板失效
- 光照变化对识别的影响

### 6.3 实时性保证

- 平衡识别准确率和处理速度
- 避免UI卡顿（识别在后台线程）

### 6.4 数据同步

- 多线程间的数据同步（识别结果 → UI更新）
- 避免竞态条件

## 七、扩展性考虑

### 7.1 可配置性

- 识别区域通过配置文件定义
- 支持不同游戏版本的适配（通过配置切换）

### 7.2 插件化

- 识别模块可插拔
- 支持自定义识别算法

### 7.3 数据更新

- 支持在线更新建议数据库
- 支持用户自定义建议规则

## 八、风险评估

### 8.1 技术风险

- 图像识别准确率可能不稳定
- 游戏更新导致识别失效
- 性能可能无法达到60fps目标

### 8.2 应对措施

- 建立完善的模板库版本管理
- 提供手动校准功能
- 支持识别频率降级（降低帧率要求）

## 九、后续优化方向

1. **机器学习集成：** 使用深度学习模型提高识别准确率
2. **云端分析：** 将复杂分析任务上传云端处理
3. **社区共享：** 用户可分享识别模板和建议规则
4. **多游戏支持：** 架构设计支持扩展到其他游戏
